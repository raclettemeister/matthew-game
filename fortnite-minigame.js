// FORTNITE MINI-GAME — generated from index.html. Do not edit this file.
// Run: node scripts/extract-fortnite.js
// ══════════════════════════════════════════════
// ══════════════════════════════════════════════
//  FORTNITE MINI-GAME — source of truth. Run: node scripts/extract-fortnite.js → fortnite-minigame.js
// ══════════════════════════════════════════════
var __fnVp = window.__FN_VIEWPORT__ || { w: 960, h: 540 };
var FN_W = __fnVp.w, FN_H = __fnVp.h;
const FN_MAP = 1800; // 3x bigger (true BR scale)
const FN_BTN_RETOUR = { x: 8, y: 8, w: 100, h: 18 };

const FN_STORM_PHASES = [[1800,900],[1200,540],[900,300],[750,165],[600,105],[450,75]];
const FN_STORM_DAMAGE_PER_PHASE = [8,10,14,18,24,32];
const FN_STORM_DAMAGE_INTERVAL = 12;
const FN_STORM_ENEMY_DAMAGE_MULT = 0.5;
const FN_CAR_SPEED = 0.25, FN_CAR_FRICTION = 0.92, FN_CAR_MAX_SPEED = 4.5;
const FN_CAR_RADIUS = 14, FN_CAR_ENTER_DIST = 32;
// Real-game style: many weak bullets, few heavy. Rarer = better (Fortnite colors).
const FN_WEAPONS = {
  pistol: { name: 'Pistol', dmg: 4, cooldown: 14, ammoMax: 16, bulletSpeed: 3.2, spread: 0.12, pellets: 1 },
  ar: { name: 'AR', dmg: 6, cooldown: 6, ammoMax: 30, bulletSpeed: 3.8, spread: 0.08, pellets: 1 },
  smg: { name: 'SMG', dmg: 4, cooldown: 3, ammoMax: 30, bulletSpeed: 3.5, spread: 0.18, pellets: 1 },
  shotgun: { name: 'Shotgun', dmg: 9, cooldown: 55, ammoMax: 6, bulletSpeed: 2.8, spread: 0.32, pellets: 6 },
  sniper: { name: 'Sniper', dmg: 58, cooldown: 90, ammoMax: 4, bulletSpeed: 7, spread: 0.01, pellets: 1 },
};
const FN_RARITIES = {
  common: { color: '#9d9d9d', dmgMult: 1.0, ammoMult: 1.0, cooldownMult: 1.0 },
  uncommon: { color: '#1cb031', dmgMult: 1.1, ammoMult: 1.05, cooldownMult: 0.98 },
  rare: { color: '#2b82c8', dmgMult: 1.25, ammoMult: 1.1, cooldownMult: 0.95 },
  epic: { color: '#9d2df2', dmgMult: 1.4, ammoMult: 1.15, cooldownMult: 0.92 },
  legendary: { color: '#e8b010', dmgMult: 1.6, ammoMult: 1.2, cooldownMult: 0.88 },
};
function fnRollRarity() {
  const r = Math.random();
  if (r < 0.02) return 'legendary';
  if (r < 0.08) return 'epic';
  if (r < 0.22) return 'rare';
  if (r < 0.50) return 'uncommon';
  return 'common';
}
function rarityThreatTier(rarity) {
  return { common: 1, uncommon: 2, rare: 3, epic: 4, legendary: 5 }[rarity] || 1;
}
const FN_TARGET_MAX_DIST = 400;
const FN_BRAWL_RADIUS = 150;
const FN_SHOOT_RANGE_MIN = 50, FN_SHOOT_RANGE_MAX = 200;
function fnPickTarget(enemy, fn) {
  const candidates = [];
  if (fn.alive) {
    const eff = fn.hp + fn.shield;
    const threat = rarityThreatTier(fn.weaponRarity || 'common');
    const dist = Math.hypot(fn.px - enemy.x, fn.py - enemy.y);
    if (dist < FN_TARGET_MAX_DIST) candidates.push({ x: fn.px, y: fn.py, hp: fn.hp, shield: fn.shield, eff, threat, dist, isPlayer: true });
  }
  for (const o of fn.enemies) {
    if (!o.alive || o === enemy) continue;
    const eff = o.hp + o.shield;
    const threat = rarityThreatTier(o.weaponRarity || 'common');
    const dist = Math.hypot(o.x - enemy.x, o.y - enemy.y);
    if (dist < FN_TARGET_MAX_DIST) candidates.push({ x: o.x, y: o.y, hp: o.hp, shield: o.shield, eff, threat, dist, entity: o });
  }
  if (candidates.length === 0) return null;
  let brawlCount = 0;
  for (const o of fn.enemies) {
    if (!o.alive || o === enemy) continue;
    if (Math.hypot(o.x - enemy.x, o.y - enemy.y) < FN_BRAWL_RADIUS) brawlCount++;
  }
  const inBrawl = brawlCount >= 2;
  if (inBrawl) {
    const inShootRange = candidates.filter(t => t.dist >= FN_SHOOT_RANGE_MIN && t.dist < FN_SHOOT_RANGE_MAX);
    if (inShootRange.length > 0) {
      let best = null, bestScore = -1;
      for (const t of inShootRange) {
        const score = t.threat * 40 + Math.max(0, 120 - t.eff);
        if (score > bestScore) { bestScore = score; best = t; }
      }
      return best;
    }
  }
  let closest = null, minDist = 1e9;
  for (const t of candidates) {
    if (t.dist < minDist) { minDist = t.dist; closest = t; }
  }
  return closest;
}
function fnPickLootTarget(enemy, fn) {
  const LOOT_SEEK_R = 380;
  let best = null, bestDist = LOOT_SEEK_R + 1;
  for (const l of fn.loot) {
    if (l.taken) continue;
    if (l.type !== 'shield' && l.type !== 'weapon') continue;
    const d = Math.hypot(l.x - enemy.x, l.y - enemy.y);
    if (d < bestDist) { bestDist = d; best = { x: l.x, y: l.y, loot: l }; }
  }
  return best;
}
function getWeaponDef(weaponType, rarity) {
  const base = FN_WEAPONS[weaponType] || FN_WEAPONS.pistol;
  const r = FN_RARITIES[rarity] || FN_RARITIES.common;
  return {
    ...base,
    dmg: Math.max(1, Math.floor(base.dmg * r.dmgMult)),
    ammoMax: Math.max(1, Math.floor(base.ammoMax * r.ammoMult)),
    cooldown: Math.max(1, Math.floor(base.cooldown * r.cooldownMult)),
  };
}
const FN_ENEMY_COUNT = 48;

var fn = null; // fortnite mini-game state (global for index + minigame)

function initFortnite() {
  const CENTER_X = 900, CENTER_Y = 900, VILLAGE_R = 285;
  const trees = [];
  for(let i = 0; i < 120; i++) {
    let x = Math.random()*FN_MAP, y = Math.random()*FN_MAP;
    if(Math.hypot(x - CENTER_X, y - CENTER_Y) < VILLAGE_R) { i--; continue; }
    trees.push({x, y, hp: 3});
  }
  const rocks = [];
  for(let i = 0; i < 60; i++) {
    let x = Math.random()*FN_MAP, y = Math.random()*FN_MAP;
    if(Math.hypot(x - CENTER_X, y - CENTER_Y) < VILLAGE_R) { i--; continue; }
    rocks.push({x, y});
  }
  const village = [
    {type:'house', x: CENTER_X-55, y: CENTER_Y-35, w: 28, h: 22, color1:'#8a6040', color2:'#6a4a28'},
    {type:'house', x: CENTER_X+22, y: CENTER_Y-42, w: 26, h: 20, color1:'#7a7050', color2:'#5a5838'},
    {type:'house', x: CENTER_X-42, y: CENTER_Y+18, w: 24, h: 24, color1:'#6a5040', color2:'#4a3828'},
    {type:'house', x: CENTER_X+18, y: CENTER_Y+22, w: 22, h: 20, color1:'#8a6848', color2:'#6a4830'},
    {type:'well', x: CENTER_X-8, y: CENTER_Y-10, w: 16, h: 12},
    {type:'square', x: CENTER_X-70, y: CENTER_Y-70, w: 140, h: 140, color1:'#4a4030', color2:'#3a3025'},
    {type:'crate', x: CENTER_X-55, y: CENTER_Y-8, w: 14, h: 12},
    {type:'crate', x: CENTER_X-38, y: CENTER_Y+5, w: 12, h: 10},
    {type:'crate', x: CENTER_X+30, y: CENTER_Y-35, w: 14, h: 12},
    {type:'crate', x: CENTER_X-25, y: CENTER_Y-50, w: 10, h: 10},
    {type:'barrier', x: CENTER_X-20, y: CENTER_Y-25, w: 24, h: 8},
    {type:'barrier', x: CENTER_X+5, y: CENTER_Y+8, w: 20, h: 6},
    {type:'barrier', x: CENTER_X-65, y: CENTER_Y+15, w: 18, h: 8},
  ];
  const enemies = [];
  for(let i = 0; i < FN_ENEMY_COUNT; i++) {
    let x, y;
    do {
      x = 100 + Math.random() * (FN_MAP - 200);
      y = 100 + Math.random() * (FN_MAP - 200);
    } while (Math.hypot(x - CENTER_X, y - CENTER_Y) < VILLAGE_R + 100);
    const hp = 12 + Math.floor(Math.random() * 8);
    const starterWeapons = ['pistol', 'ar', 'smg'];
    enemies.push({
      x, y,
      hp, shield: 0, maxHp: hp, dir: Math.random()*Math.PI*2, speed: 0.18 + Math.random()*0.2,
      shootTimer: 15 + Math.floor(Math.random() * 35),
      alive: true, strafeDir: Math.random() > 0.5 ? 1 : -1,
      strafeFlip: 40 + Math.floor(Math.random()*50),
      weaponType: starterWeapons[Math.floor(Math.random() * starterWeapons.length)],
      weaponRarity: fnRollRarity(),
      accuracy: 0.5 + Math.random() * 0.7,
    });
  }
  const loot = [];
  const weaponTypes = ['ar','smg','shotgun','sniper'];
  let placed = 0;
  while (placed < 45) {
    const x = 80 + Math.random() * (FN_MAP - 160);
    const y = 80 + Math.random() * (FN_MAP - 160);
    if (Math.hypot(x - CENTER_X, y - CENTER_Y) < VILLAGE_R + 80) continue;
    if (placed < 18) {
      const wt = weaponTypes[placed % weaponTypes.length];
      const rarity = fnRollRarity();
      const def = getWeaponDef(wt, rarity);
      loot.push({ x, y, type: 'weapon', weaponType: wt, rarity, ammo: def.ammoMax, taken: false });
    } else {
      loot.push({ x, y, type: ['shield','ammo','medkit'][placed % 3], taken: false });
    }
    placed++;
  }
  const cars = [
    { x: CENTER_X - 270, y: CENTER_Y - 180, dir: 0, vx: 0, vy: 0, hp: 80, driver: null },
    { x: CENTER_X + 210, y: CENTER_Y + 150, dir: Math.PI/2, vx: 0, vy: 0, hp: 80, driver: null },
    { x: CENTER_X - 300, y: CENTER_Y + 210, dir: Math.PI, vx: 0, vy: 0, hp: 80, driver: null },
  ];
  const spawnX = 200 + Math.random() * (FN_MAP - 400);
  const spawnY = 200 + Math.random() * (FN_MAP - 400);
  fn = {
    px: spawnX, py: spawnY, hp: 100, shield: 0, kills: 0,
    currentWeapon: 'pistol', weaponRarity: 'common', weaponAmmo: 6,
    dir: 0, speed: 1.5, shooting: false, shootCool: 0, inCar: null,
    alive: true, victory: false, oneKillDone: false,
    bullets: [], enemyBullets: [], walls: [], wallCool: 0, materials: 50,
    trees, rocks, enemies, loot, village, cars,
    storm: { radius: 1050, targetRadius: FN_STORM_PHASES[0][1], cx: CENTER_X, cy: CENTER_Y, shrinkTimer: FN_STORM_PHASES[0][0], phase: 0 },
    particles: [], messages: [], camX: 0, camY: 0,
    elapsed: 0, aliveCount: FN_ENEMY_COUNT, exitTimer: 0,
  };
}

function updateFortnite() {
  if(!fn || (!fn.alive && fn.exitTimer <= 0) || (fn.victory && fn.exitTimer <= 0) || (fn.oneKillDone && fn.exitTimer <= 0)) return;

  fn.elapsed++;

  // Exit countdown
  if(!fn.alive || fn.victory || fn.oneKillDone) { fn.exitTimer--; return; }

  if (!fn.inCar) {
    const spd = fn.speed;
    if(keys['ArrowLeft']||keys['KeyA']||keys['KeyQ']) fn.px -= spd;
    if(keys['ArrowRight']||keys['KeyD']) fn.px += spd;
    if(keys['ArrowUp']||keys['KeyW']||keys['KeyZ']) fn.py -= spd;
    if(keys['ArrowDown']||keys['KeyS']) fn.py += spd;
    fn.px = Math.max(4,Math.min(FN_MAP-4,fn.px));
    fn.py = Math.max(4,Math.min(FN_MAP-4,fn.py));
    const [px2, py2] = fnResolveCollision(fn.px, fn.py, 6);
    fn.px = px2; fn.py = py2;
  }
  if (fn.inCar) {
    const car = fn.inCar;
    fn.px = car.x; fn.py = car.y;
    if (keys['KeyE']) {
      eKeyJustPressed = false;
      fn.inCar = null; car.driver = null;
      fn.px = car.x + Math.cos(car.dir) * (FN_CAR_RADIUS + 8);
      fn.py = car.y + Math.sin(car.dir) * (FN_CAR_RADIUS + 8);
      fn.px = Math.max(4, Math.min(FN_MAP-4, fn.px));
      fn.py = Math.max(4, Math.min(FN_MAP-4, fn.py));
    } else {
      if (keys['ArrowUp']||keys['KeyW']||keys['KeyZ']) { car.vx += Math.cos(car.dir)*FN_CAR_SPEED; car.vy += Math.sin(car.dir)*FN_CAR_SPEED; }
      if (keys['ArrowDown']||keys['KeyS']) { car.vx -= Math.cos(car.dir)*FN_CAR_SPEED*0.7; car.vy -= Math.sin(car.dir)*FN_CAR_SPEED*0.7; }
      if (keys['ArrowLeft']||keys['KeyA']||keys['KeyQ']) car.dir -= 0.04;
      if (keys['ArrowRight']||keys['KeyD']) car.dir += 0.04;
      car.vx *= FN_CAR_FRICTION; car.vy *= FN_CAR_FRICTION;
      const speed = Math.hypot(car.vx, car.vy);
      if (speed > FN_CAR_MAX_SPEED) { car.vx = (car.vx/speed)*FN_CAR_MAX_SPEED; car.vy = (car.vy/speed)*FN_CAR_MAX_SPEED; }
      car.x += car.vx; car.y += car.vy;
      car.x = Math.max(FN_CAR_RADIUS, Math.min(FN_MAP-FN_CAR_RADIUS, car.x));
      car.y = Math.max(FN_CAR_RADIUS, Math.min(FN_MAP-FN_CAR_RADIUS, car.y));
      const [cx2, cy2] = fnResolveCollision(car.x, car.y, FN_CAR_RADIUS);
      car.x = cx2; car.y = cy2;
    }
  } else {
    if (eKeyJustPressed) {
      eKeyJustPressed = false;
      let nearest = null, nearestD = FN_CAR_ENTER_DIST;
      for (const car of fn.cars) {
        if (car.hp <= 0 || car.driver) continue;
        const d = Math.hypot(car.x - fn.px, car.y - fn.py);
        if (d < nearestD) { nearestD = d; nearest = car; }
      }
      if (nearest) { fn.inCar = nearest; nearest.driver = 'player'; }
    }
  }
  fn.camX = fn.px - FN_W/2;
  fn.camY = fn.py - FN_H/2;
  if(fn.shootCool > 0) fn.shootCool--;
  if(fn.wallCool > 0) fn.wallCool--;
  const mouseWorldX = mouse.x + fn.camX;
  const mouseWorldY = mouse.y + fn.camY;
  fn.dir = Math.atan2(mouseWorldY - fn.py, mouseWorldX - fn.px);
  const wdef = getWeaponDef(fn.currentWeapon, fn.weaponRarity || 'common');
  if(fn.shooting && fn.shootCool <= 0 && fn.weaponAmmo > 0) {
    const pellets = wdef.pellets || 1;
    for (let i = 0; i < pellets; i++) {
      const spread = (Math.random() - 0.5) * wdef.spread * 2;
      const a = fn.dir + spread;
      fn.bullets.push({ x: fn.px, y: fn.py, dx: Math.cos(a)*wdef.bulletSpeed, dy: Math.sin(a)*wdef.bulletSpeed, life: 50, dmg: wdef.dmg });
    }
    fn.weaponAmmo--; fn.shootCool = wdef.cooldown;
  }
  for(const b of fn.bullets) {
    b.x += b.dx; b.y += b.dy; b.life--;
    if(fnBulletHitVillage(b.x, b.y)) { b.life = 0; continue; }
    for (const car of fn.cars) {
      if (car.hp <= 0) continue;
      if (Math.hypot(b.x - car.x, b.y - car.y) < FN_CAR_RADIUS) {
        b.life = 0; car.hp -= (b.dmg != null ? b.dmg : 12);
        fnParticle(car.x, car.y, '#804020', 3);
        if (car.hp <= 0) {
          for (let i = 0; i < 25; i++) fnParticle(car.x, car.y, '#ff8040', 1);
          if (fn.inCar === car) { fn.inCar = null; car.driver = null; fn.hp -= 30; if (fn.hp <= 0) { fn.alive = false; fn.exitTimer = 120; } }
          for (const e of fn.enemies) {
            if (!e.alive) continue;
            if (Math.hypot(e.x - car.x, e.y - car.y) < 35) { e.hp -= 20; if (e.hp <= 0) { e.alive = false; fn.aliveCount--; } }
          }
        }
        break;
      }
    }
    if (b.life <= 0) continue;
    for(const e of fn.enemies) {
      if(!e.alive) continue;
      if(Math.hypot(b.x-e.x,b.y-e.y) < 8) {
        let dmg = b.dmg != null ? b.dmg : 12;
        if (e.shield > 0) { const ab = Math.min(e.shield, dmg); e.shield -= ab; dmg -= ab; }
        if (dmg > 0) { e.hp -= dmg; e.recentlyHit = 15; }
        b.life = 0;
        fnParticle(e.x,e.y,'#ff4040',5);
        if(e.hp <= 0) {
          e.alive = false; fn.kills++; fn.aliveCount--; fn.materials += 20;
          fnMsg(e.x-fn.camX, e.y-fn.camY, 'ELIMINE!', '#ff4040');
          if (typeof game !== 'undefined' && game && 'score' in game) game.score += 30;
          if(fn.kills >= 1) { fn.oneKillDone = true; fn.exitTimer = 120; }
          const dropType = Math.random() < 0.35 ? 'weapon' : ['ammo','shield','medkit'][Math.floor(Math.random()*3)];
          if (dropType === 'weapon') {
            const wts = ['ar','smg','shotgun'];
            const wt = wts[Math.floor(Math.random()*wts.length)];
            const rarity = fnRollRarity();
            const def = getWeaponDef(wt, rarity);
            fn.loot.push({x:e.x,y:e.y,type:'weapon',weaponType:wt,rarity,ammo:def.ammoMax,taken:false});
          } else fn.loot.push({x:e.x,y:e.y,type:dropType,taken:false});
        }
        break;
      }
    }
  }
  fn.bullets = fn.bullets.filter(b => b.life > 0);

  fn.storm.shrinkTimer--;
  if (fn.storm.shrinkTimer <= 0 && fn.storm.phase < FN_STORM_PHASES.length - 1) {
    fn.storm.phase++;
    const p = FN_STORM_PHASES[fn.storm.phase];
    fn.storm.targetRadius = p[1]; fn.storm.shrinkTimer = p[0];
  }
  if (fn.storm.radius > fn.storm.targetRadius) fn.storm.radius -= 0.35;
  const stormDmgIdx = Math.min(fn.storm.phase, FN_STORM_DAMAGE_PER_PHASE.length - 1);
  const stormDmg = FN_STORM_DAMAGE_PER_PHASE[stormDmgIdx];

  const SEPARATION_RADIUS = 42, SEPARATION_STRENGTH = 0.25;
  const LOOT_PICKUP_DIST = 14;
  const EXPLORE_SPEED = 0.55;
  const COMBAT_RADIUS_NO_LOOT = 320;
  const CRITICAL_HP_THRESHOLD = 25;
  const STORM_BLEND_COMBAT = 0.7;
  const STORM_BLEND_CIRCLE = 0.3;
  for(const e of fn.enemies) {
    if(!e.alive) continue;
    const target = fnPickTarget(e, fn);
    const targetDist = target ? Math.hypot(target.x - e.x, target.y - e.y) : 9999;
    const sDist = Math.hypot(e.x - fn.storm.cx, e.y - fn.storm.cy);
    const outsideStorm = sDist > fn.storm.radius;
    const hasTargetInCombatRadius = target && targetDist < COMBAT_RADIUS_NO_LOOT;
    const lootTarget = !hasTargetInCombatRadius ? fnPickLootTarget(e, fn) : null;
    const wantWeaponUpgrade = lootTarget && lootTarget.loot.type === 'weapon' && (e.weaponRarity === 'common' || e.weaponType === 'pistol');
    const wantShield = lootTarget && lootTarget.loot.type === 'shield' && e.shield < 80;
    const wantLoot = lootTarget && (e.shield < 50 || wantWeaponUpgrade || wantShield);
    const criticalHP = (e.hp + e.shield) < CRITICAL_HP_THRESHOLD;
    if (criticalHP && e.survivalTimer == null) e.survivalTimer = 60;
    if (e.survivalTimer != null) { e.survivalTimer--; if (e.survivalTimer <= 0) e.survivalTimer = null; }
    const inSurvivalMode = e.survivalTimer != null && e.survivalTimer > 0;
    let tx, ty;
    if (target && !wantLoot) { tx = target.x; ty = target.y; }
    else if (wantLoot && lootTarget) { tx = lootTarget.x; ty = lootTarget.y; }
    else if (outsideStorm) { tx = fn.storm.cx; ty = fn.storm.cy; }
    else { tx = fn.storm.cx; ty = fn.storm.cy; }
    const dx = tx - e.x, dy = ty - e.y;
    const dist = Math.hypot(dx, dy);
    const ndx = dist > 0 ? dx/dist : 0, ndy = dist > 0 ? dy/dist : 0;
    const stormDx = sDist > 0 ? (fn.storm.cx - e.x) / sDist : 0;
    const stormDy = sDist > 0 ? (fn.storm.cy - e.y) / sDist : 0;
    let sx = 0, sy = 0;
    for(const o of fn.enemies) {
      if(!o.alive || o === e) continue;
      const odx = e.x - o.x, ody = e.y - o.y;
      const odist = Math.hypot(odx,ody);
      if(odist > 0 && odist < SEPARATION_RADIUS) {
        const force = (1 - odist/SEPARATION_RADIUS) * SEPARATION_STRENGTH;
        sx += (odx/odist) * force; sy += (ody/odist) * force;
      }
    }
    e.x += sx; e.y += sy;
    e.strafeFlip--;
    if(e.strafeFlip <= 0) { e.strafeDir *= -1; e.strafeFlip = 50 + Math.floor(Math.random()*70); }
    const perpX = -ndy, perpY = ndx;
    const approachDist = 540, retreatDist = 135, comfortDist = 285;
    const flinchRetreat = e.recentlyHit && e.recentlyHit > 0;
    let moveX = 0, moveY = 0;
    if (outsideStorm && !target) {
      moveX += stormDx * e.speed;
      moveY += stormDy * e.speed;
    }
    if (target) {
      if (inSurvivalMode || flinchRetreat) {
        moveX -= ndx * e.speed * (inSurvivalMode ? 1.1 : 1.2);
        moveY -= ndy * e.speed * (inSurvivalMode ? 1.1 : 1.2);
      } else if (dist >= FN_SHOOT_RANGE_MIN && dist < FN_SHOOT_RANGE_MAX) {
        if (dist < retreatDist) {
          moveX -= ndx * e.speed; moveY -= ndy * e.speed;
        } else if (dist > approachDist) {
          moveX += ndx * e.speed * 0.95; moveY += ndy * e.speed * 0.95;
        } else {
          moveX += perpX * e.speed * 0.85 * e.strafeDir;
          moveY += perpY * e.speed * 0.85 * e.strafeDir;
          if (dist < comfortDist) {
            moveX -= ndx * e.speed * 0.4; moveY -= ndy * e.speed * 0.4;
          } else if (dist > approachDist - 30) {
            moveX += ndx * e.speed * 0.5; moveY += ndy * e.speed * 0.5;
          }
        }
      } else {
        moveX += ndx * e.speed * 0.95;
        moveY += ndy * e.speed * 0.95;
      }
      if (outsideStorm && target) {
        moveX = moveX * STORM_BLEND_COMBAT + stormDx * e.speed * STORM_BLEND_CIRCLE;
        moveY = moveY * STORM_BLEND_COMBAT + stormDy * e.speed * STORM_BLEND_CIRCLE;
      }
    } else {
      if (wantLoot && lootTarget) {
        moveX += ndx * e.speed * EXPLORE_SPEED;
        moveY += ndy * e.speed * EXPLORE_SPEED;
      } else if (!outsideStorm) {
        moveX += stormDx * e.speed * 0.5;
        moveY += stormDy * e.speed * 0.5;
      }
    }
    e.x += moveX; e.y += moveY;
    const lootDist = lootTarget ? Math.hypot(lootTarget.x - e.x, lootTarget.y - e.y) : 9999;
    if (lootTarget && lootDist < LOOT_PICKUP_DIST && lootTarget.loot && !lootTarget.loot.taken) {
      lootTarget.loot.taken = true;
      if (lootTarget.loot.type === 'shield') e.shield = Math.min(100, e.shield + 25);
      else if (lootTarget.loot.type === 'weapon') {
        e.weaponType = lootTarget.loot.weaponType || e.weaponType;
        e.weaponRarity = lootTarget.loot.rarity || e.weaponRarity;
      }
    }
    e.x = Math.max(4,Math.min(FN_MAP-4,e.x));
    e.y = Math.max(4,Math.min(FN_MAP-4,e.y));
    const [ex2, ey2] = fnResolveCollision(e.x, e.y, 5);
    e.x = ex2; e.y = ey2;
    e.shootTimer--;
    const canShoot = !e.recentlyHit || e.recentlyHit <= 0;
    if(target && canShoot && e.shootTimer <= 0 && dist >= FN_SHOOT_RANGE_MIN && dist < FN_SHOOT_RANGE_MAX) {
      const baseSpread = 0.18 * (1.4 - (e.accuracy != null ? e.accuracy : 0.85));
      const spread = Math.max(0.04, Math.min(0.22, baseSpread));
      const a = Math.atan2(dy, dx) + (Math.random() - 0.5) * spread;
      const npcWdef = getWeaponDef(e.weaponType || 'pistol', e.weaponRarity || 'common');
      const isPistol = (e.weaponType || 'pistol') === 'pistol';
      const dmgMult = isPistol ? 1.35 : 0.85;
      const npcDmg = Math.min(32, Math.max(isPistol ? 12 : 6, Math.floor(npcWdef.dmg * dmgMult)));
      const bulletSpeed = (npcWdef.bulletSpeed != null ? npcWdef.bulletSpeed : 3.2) * 1.15;
      const bulletLife = Math.ceil(500 / bulletSpeed);
      fn.enemyBullets.push({ x: e.x, y: e.y, dx: Math.cos(a) * bulletSpeed, dy: Math.sin(a) * bulletSpeed, life: bulletLife, owner: e, dmg: npcDmg });
      e.shootTimer = Math.max(25, npcWdef.cooldown * 5 + Math.floor(Math.random() * 35));
    }
    if (e.recentlyHit > 0) e.recentlyHit--;
    if(sDist > fn.storm.radius && fn.elapsed % FN_STORM_DAMAGE_INTERVAL === 0) {
      let edmg = Math.max(1, Math.floor(stormDmg * FN_STORM_ENEMY_DAMAGE_MULT));
      if (e.shield > 0) { const ab = Math.min(e.shield, edmg); e.shield -= ab; edmg -= ab; }
      if (edmg > 0) e.hp -= edmg;
      if(e.hp <= 0) { e.alive = false; fn.aliveCount--; }
    }
  }

  for(const b of fn.enemyBullets) {
    b.x += b.dx; b.y += b.dy; b.life--;
    if(fnBulletHitVillage(b.x, b.y)) { b.life = 0; continue; }
    for (const car of fn.cars) {
      if (car.hp <= 0) continue;
      if (Math.hypot(b.x - car.x, b.y - car.y) < FN_CAR_RADIUS) {
        b.life = 0; car.hp -= 8; fnParticle(car.x, car.y, '#804020', 2);
        if (car.hp <= 0 && fn.inCar === car) { fn.inCar = null; car.driver = null; fn.hp -= 30; if (fn.hp <= 0) { fn.alive = false; fn.exitTimer = 120; } }
        break;
      }
    }
    if (b.life <= 0) continue;
    for (const o of fn.enemies) {
      if (!o.alive || o === b.owner) continue;
      if (Math.hypot(b.x - o.x, b.y - o.y) < 8) {
        b.life = 0;
        let dmg = b.dmg != null ? b.dmg : (5 + Math.floor(Math.random() * 5));
        if (o.shield > 0) { const ab = Math.min(o.shield, dmg); o.shield -= ab; dmg -= ab; }
        if (dmg > 0) { o.hp -= dmg; o.recentlyHit = 15; }
        fnParticle(o.x, o.y, '#ff4040', 5);
        if (o.hp <= 0) {
          o.alive = false; fn.aliveCount--;
          const dropType = Math.random() < 0.35 ? 'weapon' : ['ammo','shield','medkit'][Math.floor(Math.random()*3)];
          if (dropType === 'weapon') {
            const wts = ['ar','smg','shotgun'];
            const wt = wts[Math.floor(Math.random()*wts.length)];
            const rarity = fnRollRarity();
            const def = getWeaponDef(wt, rarity);
            fn.loot.push({x:o.x,y:o.y,type:'weapon',weaponType:wt,rarity,ammo:def.ammoMax,taken:false});
          } else fn.loot.push({x:o.x,y:o.y,type:dropType,taken:false});
        }
        break;
      }
    }
    if (b.life <= 0) continue;
    if (fn.alive && Math.hypot(b.x-fn.px,b.y-fn.py) < 6) {
      b.life = 0;
      let dmg = (b.dmg != null ? b.dmg : (5 + Math.floor(Math.random()*5))) * 3;
      if(fn.shield > 0) { const ab = Math.min(fn.shield,dmg); fn.shield-=ab; dmg-=ab; }
      fn.hp -= dmg;
      fnParticle(fn.px,fn.py,'#ff8080',4);
      if(fn.hp <= 0) {
        fn.alive = false;
        fn.exitTimer = 120;
        fnMsg(FN_W/2, FN_H/2, 'ELIMINE!', '#ff4040');
      }
    }
    // Hit player walls
    for(let i = fn.walls.length-1; i >= 0; i--) {
      const w = fn.walls[i];
      if(Math.abs(b.x-w.x)<8 && Math.abs(b.y-w.y)<8) {
        b.life = 0;
        w.hp--;
        fnParticle(w.x,w.y,'#c09050',3);
        if(w.hp <= 0) fn.walls.splice(i,1);
        break;
      }
    }
  }
  fn.enemyBullets = fn.enemyBullets.filter(b => b.life > 0);

  for(const l of fn.loot) {
    if(l.taken) continue;
    if(Math.hypot(l.x-fn.px,l.y-fn.py) < 12) {
      l.taken = true;
      if (l.type === 'weapon') {
        const wt = l.weaponType || 'pistol';
        const rarity = l.rarity || 'common';
        const def = getWeaponDef(wt, rarity);
        if (fn.currentWeapon === wt && (fn.weaponRarity || 'common') === rarity) {
          fn.weaponAmmo = Math.min(def.ammoMax, fn.weaponAmmo + (l.ammo || def.ammoMax));
          fnMsg(l.x-fn.camX,l.y-fn.camY, '+AMMO','#f0d040');
        } else {
          fn.currentWeapon = wt;
          fn.weaponRarity = rarity;
          fn.weaponAmmo = Math.min(def.ammoMax, l.ammo || def.ammoMax);
          const rCol = FN_RARITIES[rarity].color;
          fnMsg(l.x-fn.camX,l.y-fn.camY, def.name, rCol);
        }
      } else if (l.type==='ammo') {
        const def = getWeaponDef(fn.currentWeapon, fn.weaponRarity || 'common');
        fn.weaponAmmo = Math.min(def.ammoMax, fn.weaponAmmo + 15);
        fnMsg(l.x-fn.camX,l.y-fn.camY,'+15 AMMO','#f0d040');
      } else if(l.type==='shield') { fn.shield=Math.min(100,fn.shield+25); fnMsg(l.x-fn.camX,l.y-fn.camY,'+25 SHIELD','#4080ff'); }
      else { fn.hp=Math.min(100,fn.hp+25); fnMsg(l.x-fn.camX,l.y-fn.camY,'+25 PV','#40ff80'); }
    }
  }

  // Harvest trees
  for(const t of fn.trees) {
    if(t.hp <= 0) continue;
    if(Math.hypot(t.x-fn.px,t.y-fn.py) < 12 && keys['KeyR']) {
      if(fn.elapsed % 20 === 0) {
        t.hp--;
        fn.materials += 10;
        fnParticle(t.x,t.y,'#40a040',3);
        if(t.hp <= 0) fnMsg(t.x-fn.camX,t.y-fn.camY,'+30 MATS','#c09050');
      }
    }
  }

  const pStormDist = Math.hypot(fn.px-fn.storm.cx, fn.py-fn.storm.cy);
  if(pStormDist > fn.storm.radius && fn.elapsed % FN_STORM_DAMAGE_INTERVAL === 0) {
    fn.hp -= stormDmg;
    fnParticle(fn.px, fn.py, '#8040a0', 3);
    if(fn.hp <= 0) { fn.alive = false; fn.exitTimer = 120; }
  }

  // Particles
  fn.particles = fn.particles.filter(p => { p.x += p.vx; p.y += p.vy; p.life--; return p.life > 0; });
  fn.messages = fn.messages.filter(m => { m.life--; m.y -= 0.3; return m.life > 0; });

  // Victory check
  if(fn.aliveCount <= 0 && fn.alive) {
    fn.victory = true;
    fn.exitTimer = 180;
    if (typeof game !== 'undefined' && game && 'score' in game) game.score += 200;
  }
}

function fnParticle(x,y,color,count) {
  for(let i=0;i<count;i++) {
    const a = Math.random()*Math.PI*2;
    fn.particles.push({x,y,vx:Math.cos(a)*(0.5+Math.random()),vy:Math.sin(a)*(0.5+Math.random()),color,life:20+Math.floor(Math.random()*15)});
  }
}

function fnMsg(x,y,text,color) {
  fn.messages.push({x,y,text,color,life:60});
}

function fnBulletHitVillage(bx, by) {
  for(const v of fn.village) {
    if(v.w == null || v.h == null) continue;
    if(bx >= v.x && bx <= v.x + v.w && by >= v.y && by <= v.y + v.h) return true;
  }
  return false;
}
function fnGetBlockingRects() {
  const out = [];
  for(const v of fn.village) { if(v.w != null && v.h != null) out.push(v); }
  return out;
}
function fnResolveCollision(px, py, radius) {
  const rects = fnGetBlockingRects();
  let x = px, y = py;
  for(const r of rects) {
    const cx = r.x + r.w/2, cy = r.y + r.h/2;
    const halfW = r.w/2 + radius, halfH = r.h/2 + radius;
    const dx = x - cx, dy = y - cy;
    const ox = Math.abs(dx) - halfW, oy = Math.abs(dy) - halfH;
    if(ox < 0 && oy < 0) {
      if(ox > oy) x = cx + (dx >= 0 ? 1 : -1) * halfW;
      else y = cy + (dy >= 0 ? 1 : -1) * halfH;
    }
  }
  return [x, y];
}

function drawFortnite() {
  const ox = 0, oy = 0;

  ctx.save();
  ctx.beginPath();
  ctx.rect(ox, oy, FN_W, FN_H);
  ctx.clip();

  const cx = fn.camX, cy = fn.camY;

  // Ground
  drawPixelRect(ox, oy, FN_W, FN_H, '#2a5a20');
  if(game && game.momAlert > 60 && Math.sin(Date.now()/200) > 0) {
    drawText('!! MAMAN ARRIVE !!', FN_W/2, 8, '#ff4040', 1, 'center');
  } else {
    drawText('FORTNITE BATTLE ROYALE', FN_W/2, 8, '#40d870', 1, 'center');
  }
  // Grid
  for(let gx = -cx%20; gx < FN_W; gx += 20) drawPixelRect(ox+gx, oy, 1, FN_H, '#245818');
  for(let gy = -cy%20; gy < FN_H; gy += 20) drawPixelRect(ox, oy+gy, FN_W, 1, '#245818');

  // Village au centre — place, maisons, puits
  for(const v of fn.village) {
    const sx = ox + v.x - cx, sy = oy + v.y - cy;
    if(sx + (v.w||0) < ox - 20 || sx > ox + FN_W + 20 || sy + (v.h||0) < oy - 20 || sy > oy + FN_H + 20) continue;
    if(v.type === 'square') {
      drawPixelRect(sx, sy, v.w, v.h, v.color1 || '#4a4030');
      drawPixelRect(sx + 2, sy + 2, v.w - 4, v.h - 4, v.color2 || '#3a3025');
      drawPixelRect(sx + 4, sy + 4, v.w - 8, 2, '#5a5040');
      drawPixelRect(sx + 4, sy + v.h - 6, v.w - 8, 2, '#5a5040');
    } else if(v.type === 'house') {
      drawPixelRect(sx, sy + v.h - 2, v.w, 3, 'rgba(0,0,0,0.3)');
      drawPixelRect(sx, sy, v.w, v.h, v.color1 || '#8a6040');
      drawPixelRect(sx + 2, sy + 2, v.w - 4, v.h - 4, v.color2 || '#6a4a28');
      drawPixelRect(sx + 2, sy + 2, v.w - 4, 3, '#9a7050');
      drawPixelRect(sx + Math.floor(v.w/2) - 3, sy + v.h - 10, 6, 8, '#3a2818');
    } else if(v.type === 'well') {
      drawPixelRect(sx, sy, v.w, v.h, '#505058');
      drawPixelRect(sx + 2, sy + 2, v.w - 4, v.h - 4, '#606068');
      drawPixelRect(sx + 4, sy + 4, v.w - 8, v.h - 8, '#404048');
      drawPixelRect(sx + 2, sy + 1, 4, 3, '#8a7a50');
    } else if(v.type === 'crate') {
      drawPixelRect(sx, sy, v.w, v.h, '#8a6a42');
      drawPixelRect(sx + 1, sy + 1, v.w - 2, v.h - 2, '#6a4a22');
      drawPixelRect(sx + 2, sy + 2, v.w - 4, 2, '#9a7a52');
    } else if(v.type === 'barrier') {
      drawPixelRect(sx, sy, v.w, v.h, '#505058');
      drawPixelRect(sx + 1, sy + 1, v.w - 2, v.h - 2, '#606068');
    }
  }

  // Rocks
  for(const r of fn.rocks) {
    const sx = ox+r.x-cx, sy = oy+r.y-cy;
    if(sx<ox-10||sx>ox+FN_W+10||sy<oy-10||sy>oy+FN_H+10) continue;
    drawPixelRect(sx-4,sy-3,8,6,'#707070');
    drawPixelRect(sx-3,sy-4,6,8,'#808080');
    drawPixelRect(sx-2,sy-2,4,4,'#909090');
  }

  // Trees
  for(const t of fn.trees) {
    if(t.hp<=0) continue;
    const sx = ox+t.x-cx, sy = oy+t.y-cy;
    if(sx<ox-10||sx>ox+FN_W+10||sy<oy-10||sy>oy+FN_H+10) continue;
    drawPixelRect(sx-1,sy-1,3,5,'#5a3820');
    drawPixelRect(sx-4,sy-5,9,5,'#2a8a20');
    drawPixelRect(sx-3,sy-7,7,4,'#30a028');
  }

  for(const l of fn.loot) {
    if(l.taken) continue;
    const sx = ox+l.x-cx, sy = oy+l.y-cy;
    if(sx<ox-10||sx>ox+FN_W+10||sy<oy-10||sy>oy+FN_H+10) continue;
    const col = l.type==='weapon' ? (FN_RARITIES[l.rarity] ? FN_RARITIES[l.rarity].color : '#9d9d9d') : l.type==='ammo' ? '#f0d040' : l.type==='shield' ? '#4080ff' : '#40ff80';
    if(l.type === 'weapon') {
      const wt = l.weaponType || 'pistol';
      const dark = '#2a2a2a';
      if(wt === 'pistol') {
        drawPixelRect(sx-3,sy-1,6,2,col);
        drawPixelRect(sx-2,sy+1,2,3,dark);
      } else if(wt === 'sniper') {
        drawPixelRect(sx-5,sy-1,10,2,col);
        drawPixelRect(sx-4,sy-2,8,1,'#1a1a1a');
        drawPixelRect(sx-1,sy+1,2,3,dark);
        drawPixelRect(sx-6,sy-1,2,3,col);
      } else if(wt === 'shotgun') {
        drawPixelRect(sx-4,sy-2,8,3,col);
        drawPixelRect(sx-3,sy+1,3,3,dark);
      } else {
        drawPixelRect(sx-4,sy-1,8,2,col);
        drawPixelRect(sx-3,sy+1,2,3,dark);
        drawPixelRect(sx-4,sy,6,1,'#1a1a1a');
      }
      if(Math.sin(Date.now()/200)>0) { ctx.strokeStyle=col; ctx.lineWidth=1; ctx.strokeRect(sx-5,sy-4,10,8); }
    } else {
      drawPixelRect(sx-3,sy-3,6,6,col);
      drawPixelRect(sx-2,sy-2,4,4,'#fff8');
      if(Math.sin(Date.now()/200)>0) { ctx.strokeStyle=col; ctx.lineWidth=1; ctx.strokeRect(sx-4,sy-4,8,8); }
    }
    if(l.type==='weapon' && FN_WEAPONS[l.weaponType]) drawText((FN_WEAPONS[l.weaponType].name||'').slice(0,2), sx, sy-7, '#fff', 1, 'center');
  }

  // Player walls
  for(const w of fn.walls) {
    const sx = ox+w.x-cx, sy = oy+w.y-cy;
    const alpha = w.hp/3;
    drawPixelRect(sx-6,sy-6,12,12,`rgba(180,140,80,${alpha})`);
    drawPixelRect(sx-5,sy-5,10,10,`rgba(210,170,110,${alpha})`);
    drawPixelRect(sx-4,sy-1,8,2,'#8a6a40');
  }

  for(const e of fn.enemies) {
    if(!e.alive) continue;
    const sx = ox+e.x-cx, sy = oy+e.y-cy;
    if(sx<ox-10||sx>ox+FN_W+10||sy<oy-10||sy>oy+FN_H+10) continue;
    drawPixelRect(sx-3,sy-3,7,7,'#e04040');
    drawPixelRect(sx-2,sy-4,5,2,'#181820');
    drawPixelRect(sx-1,sy-2,3,3,'#f0c090');
    const maxHp = e.maxHp || 6;
    drawPixelRect(sx-4,sy-7,9,2,'#303030');
    drawPixelRect(sx-4,sy-7,Math.max(0,9*(e.hp/maxHp)),2,'#ff4040');
    if(e.shield > 0) drawPixelRect(sx-4,sy-9,Math.max(0,9*Math.min(1,e.shield/75)),2,'#4080ff');
  }
  for(const car of fn.cars) {
    if(car.hp <= 0) continue;
    const sx = ox + car.x - cx, sy = oy + car.y - cy;
    if(sx < -30 || sx > FN_W + 30 || sy < -30 || sy > FN_H + 30) continue;
    ctx.save();
    ctx.translate(sx, sy);
    ctx.rotate(car.dir);
    const w = 28, h = 16;
    const body = '#2d2d38';
    const bodyHighlight = '#3d3d4a';
    const cabin = '#3a3a48';
    const windscreen = '#507090';
    const wheel = '#1a1a20';
    const rim = '#505560';
    const headlight = '#fff8c0';
    const taillight = '#ff4040';
    drawPixelRect(-w, -h, w * 2, h * 2, body);
    drawPixelRect(-w + 2, -h + 2, w * 2 - 4, h * 2 - 4, bodyHighlight);
    drawPixelRect(-w + 6, -h + 2, 16, 12, cabin);
    drawPixelRect(-w + 8, -h + 3, 12, 8, windscreen);
    drawPixelRect(-w + 2, -h + 4, 6, 8, body);
    drawPixelRect(w - 8, -h + 4, 6, 8, body);
    drawPixelRect(-w - 2, -h - 3, 10, 6, wheel);
    drawPixelRect(-w - 1, -h - 2, 6, 4, rim);
    drawPixelRect(w - 8, -h - 3, 10, 6, wheel);
    drawPixelRect(w - 7, -h - 2, 6, 4, rim);
    drawPixelRect(-w - 2, h - 3, 10, 6, wheel);
    drawPixelRect(-w - 1, h - 2, 6, 4, rim);
    drawPixelRect(w - 8, h - 3, 10, 6, wheel);
    drawPixelRect(w - 7, h - 2, 6, 4, rim);
    drawPixelRect(-w + 4, -h - 1, 4, 2, taillight);
    drawPixelRect(-w + 10, -h - 1, 4, 2, taillight);
    drawPixelRect(w - 14, -h - 1, 4, 2, headlight);
    drawPixelRect(w - 8, -h - 1, 4, 2, headlight);
    ctx.restore();
  }

  // Player
  if(fn.alive) {
    const sx = ox+fn.px-cx, sy = oy+fn.py-cy;
    drawPixelRect(sx-3,sy-3,7,7,PAL.shirt);
    drawPixelRect(sx-2,sy-4,5,2,PAL.hair);
    drawPixelRect(sx-1,sy-2,3,3,PAL.skin);
    // Gun direction
    const gx = Math.cos(fn.dir)*6, gy = Math.sin(fn.dir)*6;
    drawPixelRect(sx+gx-1,sy+gy-1,3,3,'#505050');
  }

  // Crosshair at mouse position
  const crossX = mouse.x, crossY = mouse.y;
  if(crossX > ox && crossX < ox+FN_W && crossY > oy && crossY < oy+FN_H) {
    const cc = fn.shooting ? '#ff4040' : '#f0f040';
    drawPixelRect(crossX - 4, crossY, 3, 1, cc);
    drawPixelRect(crossX + 2, crossY, 3, 1, cc);
    drawPixelRect(crossX, crossY - 4, 1, 3, cc);
    drawPixelRect(crossX, crossY + 2, 1, 3, cc);
    // Aim line from player to cursor
    ctx.strokeStyle = fn.shooting ? '#ff404060' : '#f0f04040';
    ctx.lineWidth = 1;
    ctx.setLineDash([3,3]);
    const psx = ox + fn.px - cx, psy = oy + fn.py - cy;
    ctx.beginPath(); ctx.moveTo(psx, psy); ctx.lineTo(crossX, crossY); ctx.stroke();
    ctx.setLineDash([]);
  }

  // Bullets
  for(const b of fn.bullets) {
    const sx = ox+b.x-cx, sy = oy+b.y-cy;
    drawPixelRect(sx-1,sy-1,3,3,'#f0f040');
  }
  for(const b of fn.enemyBullets) {
    const sx = ox+b.x-cx, sy = oy+b.y-cy;
    drawPixelRect(sx-1,sy-1,2,2,'#ff6060');
  }

  // Particles
  for(const p of fn.particles) {
    const sx = ox+p.x-cx, sy = oy+p.y-cy;
    ctx.globalAlpha = p.life/35;
    drawPixelRect(sx,sy,2,2,p.color);
    ctx.globalAlpha = 1;
  }

  // Storm overlay
  // Draw purple outside storm circle
  const sCx = ox + fn.storm.cx - cx;
  const sCy = oy + fn.storm.cy - cy;
  const sR = fn.storm.radius;
  ctx.fillStyle = 'rgba(100,40,160,0.35)';
  ctx.beginPath();
  ctx.rect(ox,oy,FN_W,FN_H);
  ctx.arc(sCx, sCy, sR, 0, Math.PI*2, true);
  ctx.fill();

  // Storm edge
  ctx.strokeStyle = 'rgba(160,60,220,0.6)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(sCx, sCy, sR, 0, Math.PI*2);
  ctx.stroke();

  ctx.restore();

  // ── FORTNITE HUD ──
  // Bouton Retour (en haut à gauche)
  const br = FN_BTN_RETOUR;
  drawPixelRect(br.x - 2, br.y - 2, br.w + 4, br.h + 4, PAL.uiBorder);
  drawPixelRect(br.x, br.y, br.w, br.h, '#4060a0');
  drawText('RETOUR CHAMBRE', br.x + br.w/2, br.y + br.h/2 - 2, '#c0e0ff', 1, 'center');

  const hudRight = FN_W - 10, hudBottom = FN_H - 8;
  const barW = 70, barH = 5, lineH = 12;

  // Kills, Mats, Ammo (lignes en bas) — weapon color = rarity (Fortnite)
  const wdef = getWeaponDef(fn.currentWeapon, fn.weaponRarity || 'common');
  const weaponColor = FN_RARITIES[fn.weaponRarity] ? FN_RARITIES[fn.weaponRarity].color : '#f0d040';
  drawText(`KILLS:${fn.kills}`, hudRight, hudBottom, '#ff4040', 1, 'right');
  drawText(`MATS:${fn.materials}`, hudRight, hudBottom - lineH, '#c09050', 1, 'right');
  drawText(`${wdef.name} ${fn.weaponAmmo}/${wdef.ammoMax}`, hudRight, hudBottom - lineH*2, weaponColor, 1, 'right');

  // Barre Shield (au-dessus des textes)
  const shY = hudBottom - lineH*3 - barH - 2;
  drawText('SH', hudRight - barW - 8, shY + 1, '#4080ff', 1, 'right');
  drawPixelRect(hudRight - barW, shY, barW, barH, '#303030');
  drawPixelRect(hudRight - barW, shY, barW*fn.shield/100, barH, '#4080ff');

  // Barre PV (au-dessus du shield)
  const hpY = shY - barH - lineH;
  drawText('PV', hudRight - barW - 8, hpY + 1, '#40ff80', 1, 'right');
  drawPixelRect(hudRight - barW, hpY, barW, barH, '#303030');
  drawPixelRect(hudRight - barW, hpY, barW*fn.hp/100, barH, '#40ff80');

  // Alive (au centre du viewport Fortnite)
  drawText(`${fn.aliveCount+1} VIVANTS`, ox+FN_W/2, oy+FN_H-8, '#f0f0f0', 1, 'center');

  // Controls hint
  drawText('CLIC/ESPACE:TIRER  E:VOITURE  DROIT/B:MUR  FLECHES:BOUGER  R:RECOLTER  ESC:QUITTER', FN_W/2, FN_H-18, '#606080', 1, 'center');

  // Floating messages
  for(const m of fn.messages) {
    ctx.globalAlpha = Math.min(1, m.life/20);
    drawText(m.text, ox+m.x, oy+m.y, m.color, 1, 'center');
    ctx.globalAlpha = 1;
  }

  // Victory / death / 1 kill overlay
  if(fn.victory) {
    drawPixelRect(ox, oy+FN_H/2-20, FN_W, 40, '#000000C0');
    drawText('#1 VICTORY ROYALE!', ox+FN_W/2, oy+FN_H/2-10, '#f0d040', 2, 'center');
    drawText(`${fn.kills} KILLS  +200 PTS`, ox+FN_W/2, oy+FN_H/2+10, '#40ff80', 1, 'center');
  }
  if(fn.oneKillDone && !fn.victory) {
    drawPixelRect(ox, oy+FN_H/2-20, FN_W, 40, '#000000C0');
    drawText('1 KILL!', ox+FN_W/2, oy+FN_H/2-10, '#40ff80', 2, 'center');
    drawText('RANGE TA CHAMBRE POUR GAGNER', ox+FN_W/2, oy+FN_H/2+10, '#e0e0e0', 1, 'center');
  }
  if(!fn.alive) {
    drawPixelRect(ox, oy+FN_H/2-15, FN_W, 30, '#400000C0');
    drawText('TU ES ELIMINE!', ox+FN_W/2, oy+FN_H/2-8, '#ff4040', 2, 'center');
    drawText(`${fn.kills} KILLS`, ox+FN_W/2, oy+FN_H/2+8, '#ff8080', 1, 'center');
  }

}

function stopFortnite() {
  if (fn) {
    if (typeof game !== 'undefined' && game) {
      if ('fnKills' in game) game.fnKills += fn.kills;
      if ('fortniteTime' in game) game.fortniteTime += Math.floor(fn.elapsed/60);
      if ((fn.victory || fn.oneKillDone) && 'cleaned' in game && 'totalItems' in game && game.cleaned >= game.totalItems) game.phase = 'win';
      game.playingFortnite = false;
    }
  }
  fn = null;
  if (typeof game !== 'undefined' && game) game.playingFortnite = false;
}

// Expose for minigame.html
window.FN_BTN_RETOUR = FN_BTN_RETOUR;
window.initFortnite = initFortnite;
window.updateFortnite = updateFortnite;
window.drawFortnite = drawFortnite;
window.stopFortnite = stopFortnite;
window.fnRef = function() { return fn; };
